/*
 * Copyright (c) 2016 Yookue Ltd. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.yookue.commonplexus.springutil.util;


import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Predicate;
import javax.lang.model.element.Modifier;
import jakarta.annotation.Nonnull;
import jakarta.annotation.Nullable;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.BooleanUtils;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.RandomStringUtils;
import org.apache.commons.lang3.StringUtils;
import org.springframework.core.DefaultParameterNameDiscoverer;
import org.springframework.core.annotation.AnnotatedElementUtils;
import org.springframework.util.ClassUtils;
import org.springframework.util.CollectionUtils;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeVariableName;
import com.yookue.commonplexus.javaseutil.constant.StringVariantConst;
import com.yookue.commonplexus.javaseutil.util.ArrayUtilsWraps;
import com.yookue.commonplexus.javaseutil.util.AssertMessageWraps;
import com.yookue.commonplexus.javaseutil.util.BooleanUtilsWraps;
import com.yookue.commonplexus.javaseutil.util.CollectionPlainWraps;
import com.yookue.commonplexus.javaseutil.util.FileUtilsWraps;
import com.yookue.commonplexus.javaseutil.util.MapPlainWraps;
import com.yookue.commonplexus.javaseutil.util.MethodUtilsWraps;
import com.yookue.commonplexus.javaseutil.util.ObjectUtilsWraps;
import com.yookue.commonplexus.javaseutil.util.StringUtilsWraps;
import com.yookue.commonplexus.javaseutil.util.TypeUtilsWraps;
import com.yookue.commonplexus.javaseutil.util.UtilDateWraps;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;
import lombok.experimental.Accessors;


/**
 * Utilities for generating java source files that could ignore exceptions during execution
 *
 * @author David Hsing
 * @see com.squareup.javapoet.JavaFile
 * @see "https://github.com/square/javapoet"
 */
@SuppressWarnings({"unused", "BooleanMethodIsAlwaysInverted", "UnusedReturnValue"})
public abstract class QuietMethodWraps {
    private static final String GENERATED_BY = String.format("Generated by {@link %s}", ClassUtils.getQualifiedName(QuietMethodWraps.class));    // $NON-NLS-1$

    @Nullable
    public static JavaFile buildMethodsAsFile(@Nullable String className, @Nullable BuildParam buildParam) throws ClassNotFoundException {
        if (StringUtils.isBlank(className)) {
            throw new IllegalArgumentException(AssertMessageWraps.hasText("className"));    // $NON-NLS-1$
        }
        return buildMethodsAsFile(ClassUtils.forName(className, null), buildParam);
    }

    @Nullable
    public static JavaFile buildMethodsAsFile(@Nullable Class<?> classType, @Nullable BuildParam buildParam) {
        if (classType == null) {
            throw new IllegalArgumentException(AssertMessageWraps.notNull("classType"));    // $NON-NLS-1$
        }
        buildParam = ObjectUtils.defaultIfNull(buildParam, new BuildParam());
        String srcType = ClassUtils.getShortName(classType);
        String destType = StringUtils.join(buildParam.typePrefix, srcType, buildParam.typeSuffix);
        // Generate type content
        TypeSpec.Builder typeBuilder = TypeSpec.classBuilder(destType).addModifiers(buildParam.typeModifiers);
        doWithTypeInternal(classType, typeBuilder, buildParam);
        // Generate method content
        List<Method> methods = MethodUtilsWraps.getDeclaredMethodsToList(classType, buildParam.methodFilter);
        if (CollectionUtils.isEmpty(methods)) {
            if (BooleanUtils.isTrue(buildParam.stopIfEmpty)) {
                return null;
            }
        } else {
            for (Method method : methods) {
                doWithMethodInternal(method, typeBuilder, buildParam);
            }
        }
        // Generate file content
        String destPackage = StringUtils.defaultIfBlank(buildParam.packageName, ClassUtils.getPackageName(classType));
        JavaFile.Builder fileBuilder = JavaFile.builder(destPackage, typeBuilder.build());
        doWithFileInternal(fileBuilder, buildParam);
        return fileBuilder.build();
    }

    @Nullable
    public static String buildMethodsAsString(@Nullable String className, @Nullable BuildParam buildParam) throws ClassNotFoundException {
        JavaFile file = buildMethodsAsFile(className, buildParam);
        return (file == null) ? null : file.toString();
    }

    @Nullable
    public static String buildMethodsAsString(@Nullable Class<?> classType, @Nullable BuildParam buildParam) {
        JavaFile file = buildMethodsAsFile(classType, buildParam);
        return (file == null) ? null : file.toString();
    }

    public static boolean writeMethods(@Nullable String className, @Nullable BuildParam buildParam, @Nullable File output, @Nullable Charset charset, boolean append) throws ClassNotFoundException, IOException {
        if (StringUtils.isBlank(className) || output == null) {
            return false;
        }
        FileUtils.forceMkdirParent(output);
        return writeMethods(className, buildParam, FileUtils.openOutputStream(output, append), charset);
    }

    public static boolean writeMethods(@Nullable String className, @Nullable BuildParam buildParam, @Nullable OutputStream output, @Nullable Charset charset) throws ClassNotFoundException, IOException {
        if (StringUtils.isBlank(className) || output == null) {
            return false;
        }
        String content = buildMethodsAsString(className, buildParam);
        if (StringUtils.isBlank(content)) {
            return false;
        }
        IOUtils.write(content, output, ObjectUtils.defaultIfNull(charset, Charset.defaultCharset()));
        return true;
    }

    public static boolean writeMethods(@Nullable Class<?> classType, @Nullable BuildParam buildParam, @Nullable File output, @Nullable Charset charset) throws IOException {
        return writeMethods(classType, buildParam, output, charset, false);
    }

    @SuppressWarnings({"DataFlowIssue", "RedundantSuppression"})
    public static boolean writeMethods(@Nullable Class<?> classType, @Nullable BuildParam buildParam, @Nullable File output, @Nullable Charset charset, boolean append) throws IOException {
        if (ObjectUtils.anyNull(classType, output)) {
            return false;
        }
        FileUtils.forceMkdirParent(output);
        return writeMethods(classType, buildParam, FileUtils.openOutputStream(output, append), charset);
    }

    public static boolean writeMethods(@Nullable Class<?> classType, @Nullable BuildParam buildParam, @Nullable OutputStream output, @Nullable Charset charset) throws IOException {
        if (ObjectUtils.anyNull(classType, output)) {
            return false;
        }
        String content = buildMethodsAsString(classType, buildParam);
        if (StringUtils.isBlank(content)) {
            return false;
        }
        IOUtils.write(content, output, ObjectUtils.defaultIfNull(charset, Charset.defaultCharset()));
        return true;
    }

    protected static void doWithTypeInternal(@Nonnull Class<?> classType, @Nonnull TypeSpec.Builder typeBuilder, @Nonnull BuildParam buildParam) {
        // Javadoc content
        CodeBlock.Builder docBuilder = CodeBlock.builder();
        StringUtilsWraps.ifNotBlank(buildParam.typeDescription, element -> docBuilder.add("$L", element));    // $NON-NLS-1$
        BooleanUtilsWraps.ifNotFalse(buildParam.docGeneratedBy, () -> docBuilder.add("$L", GENERATED_BY));    // $NON-NLS-1$
        BooleanUtilsWraps.ifTrue(buildParam.docCreatedOn, () -> {
            JavapoetPlainWraps.addLineSeparator(docBuilder, true);
            docBuilder.add("Created on $L", UtilDateWraps.formatCurrentDate());    // $NON-NLS-1$
        });
        BooleanUtilsWraps.ifTrue(buildParam.docSee, () -> {
            JavapoetPlainWraps.addLineSeparator(docBuilder, true, 2);
            docBuilder.add("@see $L", ClassUtils.getQualifiedName(classType));    // $NON-NLS-1$
        });
        if (BooleanUtils.isTrue(buildParam.docDeprecated) || AnnotatedElementUtils.hasAnnotation(classType, Deprecated.class)) {
            JavapoetPlainWraps.addLineSeparator(docBuilder, true, 2);
            StringUtilsWraps.ifBlankOrElse(buildParam.docDeprecatedContent, element -> docBuilder.add("@deprecated"), element -> docBuilder.addStatement("@deprecated $L", element));    // $NON-NLS-1$ // $NON-NLS-2$
            typeBuilder.addAnnotation(AnnotationSpec.builder(Deprecated.class).build());
        }
        CollectionPlainWraps.forEach(buildParam.apiNotes, element -> {
            JavapoetPlainWraps.addLineSeparator(docBuilder, true);
            docBuilder.add("@apiNote $L", element);    // $NON-NLS-1$
        }, StringUtils::isNotBlank);
        CollectionPlainWraps.forEach(buildParam.implNotes, element -> {
            JavapoetPlainWraps.addLineSeparator(docBuilder, true);
            docBuilder.add("@implNote $L", element);    // $NON-NLS-1$
        }, StringUtils::isNotBlank);
        CollectionPlainWraps.forEach(buildParam.implSpecs, element -> {
            JavapoetPlainWraps.addLineSeparator(docBuilder, true);
            docBuilder.add("@implSpec $L", element);    // $NON-NLS-1$
        }, StringUtils::isNotBlank);
        CollectionPlainWraps.forEach(buildParam.serials, element -> {
            JavapoetPlainWraps.addLineSeparator(docBuilder, true);
            docBuilder.add("@serial $L", element);    // $NON-NLS-1$
        }, StringUtils::isNotBlank);
        CollectionPlainWraps.forEach(buildParam.sees, element -> {
            JavapoetPlainWraps.addLineSeparator(docBuilder, true);
            docBuilder.add("@see $L", element);    // $NON-NLS-1$
        }, StringUtils::isNotBlank);
        CollectionPlainWraps.forEach(buildParam.authors, element -> {
            JavapoetPlainWraps.addLineSeparator(docBuilder, true);
            docBuilder.add("@author $L", element);    // $NON-NLS-1$
        }, StringUtils::isNotBlank);
        StringUtilsWraps.ifNotBlank(buildParam.docVersion, element -> {
            JavapoetPlainWraps.addLineSeparator(docBuilder, true);
            docBuilder.add("@version $L", element);    // $NON-NLS-1$
        });
        StringUtilsWraps.ifNotBlank(buildParam.docSince, element -> {
            JavapoetPlainWraps.addLineSeparator(docBuilder, true);
            docBuilder.add("@since $L", element);    // $NON-NLS-1$
        });
        typeBuilder.addJavadoc(docBuilder.build());
        // Class annotations
        if (CollectionUtils.isEmpty(buildParam.suppressWarnings)) {
            return;
        }
        AtomicBoolean hasMemberAtom = new AtomicBoolean(false);
        AnnotationSpec.Builder warningsSpec = AnnotationSpec.builder(SuppressWarnings.class);
        CollectionPlainWraps.forEach(buildParam.suppressWarnings, element -> {
            warningsSpec.addMember("value", "$S", element);    // $NON-NLS-1$ // $NON-NLS-2$
            hasMemberAtom.set(true);
        }, StringUtils::isNotBlank);
        if (hasMemberAtom.get()) {
            typeBuilder.addAnnotation(warningsSpec.build());
        }
    }

    /**
     * @see org.springframework.core.DefaultParameterNameDiscoverer
     */
    protected static void doWithMethodInternal(@Nonnull Method method, @Nonnull TypeSpec.Builder typeBuilder, @Nonnull BuildParam buildParam) {
        Modifier[] methodModifiers = MethodUtilsWraps.isStatic(method) ? new Modifier[]{Modifier.PUBLIC, Modifier.STATIC} : new Modifier[]{Modifier.PUBLIC};
        String methodName = StringUtils.join(buildParam.methodPrefix, method.getName(), buildParam.methodSuffix);
        Type returnType = method.getGenericReturnType();
        MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName).addModifiers(methodModifiers).returns(returnType);
        // Deprecated annotation
        if (AnnotatedElementUtils.hasAnnotation(method, Deprecated.class)) {
            methodBuilder.addAnnotation(AnnotationSpec.builder(Deprecated.class).build());
        }
        // Declare generic types
        if (MethodUtilsWraps.returnGeneric(method)) {
            // @see "https://www.cnblogs.com/one777/p/7833789.html"
            if (returnType instanceof TypeVariable) {
                methodBuilder.addTypeVariable(TypeVariableName.get((TypeVariable<?>) returnType));
            } else if (returnType instanceof ParameterizedType) {
                Type[] actualTypes = ((ParameterizedType) method.getGenericReturnType()).getActualTypeArguments();
                ArrayUtilsWraps.forEach(actualTypes, element -> methodBuilder.addTypeVariable(TypeVariableName.get(element.getTypeName())));
            }
        }
        // Determine parameter types and names
        Map<String, Type> nameTypes = new LinkedHashMap<>();
        if (!MethodUtilsWraps.isStatic(method)) {
            nameTypes.put(StringVariantConst.INSTANCE, method.getDeclaringClass());
        }
        if (method.getParameterCount() > 0) {
            Type[] types = method.getGenericParameterTypes();
            DefaultParameterNameDiscoverer discoverer = new DefaultParameterNameDiscoverer();
            String[] names = discoverer.getParameterNames(method);
            if (ArrayUtils.isEmpty(names)) {
                ArrayUtilsWraps.forEachIndexing(types, (index, element) -> nameTypes.put(String.format("arg%d", index), element));    // $NON-NLS-1$
            } else {
                ArrayUtilsWraps.forEachIndexing(types, (index, element) -> {
                    String name = StringUtils.defaultIfBlank(ArrayUtils.get(names, index), String.format("arg%d", index));    // $NON-NLS-1$
                    while (MapPlainWraps.containsKey(nameTypes, name)) {
                        name = StringUtils.lowerCase(RandomStringUtils.secure().next(6));
                    }
                    nameTypes.put(name, element);
                });
            }
        }
        AnnotationSpec nullableSpec = null;
        if (BooleanUtils.isTrue(buildParam.nullableAnnotation) && StringUtils.isNotBlank(buildParam.nullableAnnotationImpl)) {
            ClassName nullableName = ClassName.bestGuess(buildParam.nullableAnnotationImpl);
            nullableSpec = AnnotationSpec.builder(nullableName).build();
        }
        if (nullableSpec != null && !MethodUtilsWraps.returnPrimitive(method) && !MethodUtilsWraps.returnVoid(method)) {
            methodBuilder.addAnnotation(nullableSpec);
        }
        if (!MethodUtilsWraps.isStatic(method)) {
            // Remove "instance" element from mappings if non-static method
            nameTypes.remove(StringVariantConst.INSTANCE);
            // Append "instance" parameter to method if it's non-static
            ParameterSpec.Builder paramBuilder = ParameterSpec.builder(method.getDeclaringClass(), StringVariantConst.INSTANCE);
            ObjectUtilsWraps.ifNotNull(nullableSpec, paramBuilder::addAnnotation);
            methodBuilder.addParameter(paramBuilder.build());
        }
        // Build method parameters
        for (Map.Entry<String, Type> entry : nameTypes.entrySet()) {
            ParameterSpec.Builder paramBuilder = ParameterSpec.builder(entry.getValue(), entry.getKey());
            if (nullableSpec != null && TypeUtilsWraps.isNotPrimitive(entry.getValue())) {
                paramBuilder.addAnnotation(nullableSpec);
            }
            methodBuilder.addParameter(paramBuilder.build());
        }
        // Build method body
        if (!MethodUtilsWraps.isStatic(method)) {
            methodBuilder.beginControlFlow("if ($L == null)", StringVariantConst.INSTANCE);    // $NON-NLS-1$
            JavapoetPlainWraps.addReturnStatement(method, methodBuilder, false);
            methodBuilder.endControlFlow();
        }
        methodBuilder.beginControlFlow("try");    // $NON-NLS-1$
        String jointParams = StringUtilsWraps.wrapWithParentheses(StringUtilsWraps.joinWithCommaSpace(nameTypes.keySet()), false);
        if (MethodUtilsWraps.isStatic(method)) {
            String pattern = StringUtils.join((method.getReturnType() == Void.TYPE ? null : "return "), "$T.$L$L");    // $NON-NLS-1$
            methodBuilder.addStatement(pattern, method.getDeclaringClass(), method.getName(), jointParams);    // $NON-NLS-1$
        } else {
            String pattern = StringUtils.join((method.getReturnType() == Void.TYPE ? null : "return "), "$L.$L$L");    // $NON-NLS-1$
            methodBuilder.addStatement(pattern, StringVariantConst.INSTANCE, method.getName(), jointParams);    // $NON-NLS-1$
        }
        boolean throwable = Arrays.stream(method.getExceptionTypes()).anyMatch(element -> element == Throwable.class);
        methodBuilder.nextControlFlow("catch ($T ignored)", (throwable ? Throwable.class : Exception.class)).endControlFlow();    // $NON-NLS-1$
        // Build method return
        JavapoetPlainWraps.addReturnStatement(method, methodBuilder, true);
        typeBuilder.addMethod(methodBuilder.build());
    }

    protected static void doWithFileInternal(@Nonnull JavaFile.Builder fileBuilder, @Nonnull BuildParam buildParam) {
        fileBuilder.skipJavaLangImports(true);
        if (buildParam.tabIndents > 0) {
            fileBuilder.indent(StringUtils.repeat(StringUtils.SPACE, buildParam.tabIndents));
        }
        if (StringUtils.isNotBlank(buildParam.commentFile)) {
            List<String> comments = FileUtilsWraps.readLines(new File(buildParam.commentFile), buildParam.commentFileCharset);
            CollectionPlainWraps.forEach(comments, element -> fileBuilder.addFileComment("$L", element), StringUtils::isNotEmpty);    // $NON-NLS-1$
        }
        CollectionPlainWraps.forEach(buildParam.fileComments, element -> fileBuilder.addFileComment("$L", element), StringUtils::isNotEmpty);    // $NON-NLS-1$
    }

    /**
     * Structure for building quiet methods
     *
     * @author David Hsing
     * @see "https://stackoverflow.com/questions/578363/javadoc-version-and-since"
     */
    @Accessors(chain = true)
    @Getter
    @Setter
    @ToString
    @SuppressWarnings("unused")
    public static class BuildParam {
        /**
         * Comment content, which will be included in the generated class
         * This content will be used posterior to the {@code commentFile}
         */
        private final List<String> fileComments = new ArrayList<>();

        /**
         * Content that will be used with the {@code @apiNote} annotation in the javadoc, for the generated class
         */
        private final List<String> apiNotes = new ArrayList<>();

        /**
         * Content that will be used with the {@code @implNote} annotation in the javadoc, for the generated class
         */
        private final List<String> implNotes = new ArrayList<>();

        /**
         * Content that will be used with the {@code @implSpec} annotation in the javadoc, for the generated class
         */
        private final List<String> implSpecs = new ArrayList<>();

        /**
         * Content that will be used with the {@code @serial} annotation in the javadoc, for the generated class
         */
        private final List<String> serials = new ArrayList<>();

        /**
         * Content that will be used with the {@code @see} annotation in the javadoc, for the generated class
         */
        private final List<String> sees = new ArrayList<>();

        /**
         * Content that will be used with the {@code @author} annotation in the javadoc, for the generated class
         */
        private final List<String> authors = new ArrayList<>();

        /**
         * Suppress warnings that will be used in the {@code @SuppressWarnings} annotation of the generated class
         */
        private final List<String> suppressWarnings = CollectionPlainWraps.newArrayListWithin("unused", "BooleanMethodIsAlwaysInverted", "UnusedReturnValue");    // $NON-NLS-1$ // $NON-NLS-2$ // $NON-NLS-3$

        /**
         * Comment template file path, which will be included in the generated class
         * This content will be used prior to the {@code fileComments}
         */
        private String commentFile;

        /**
         * Charset for the comment template file
         */
        private Charset commentFileCharset;

        /**
         * package name, which will be declared in the generated class
         * If empty, the package of the target class will be used
         */
        private String packageName;

        /**
         * Modifiers for the generated java class
         */
        private Modifier[] typeModifiers = new Modifier[]{Modifier.PUBLIC, Modifier.ABSTRACT};

        /**
         * Description for the generated class, will be used in the javadoc
         */
        private String typeDescription;

        /**
         * Declaration of this generating tool class, will be used in the javadoc
         */
        private Boolean docGeneratedBy;

        /**
         * Created date for the generated class, will be used in the javadoc
         */
        private Boolean docCreatedOn;

        /**
         * Add a @see source for the generated class, will be used in the javadoc
         */
        private Boolean docSee = Boolean.TRUE;

        /**
         * Indicate whether using the {@code @Deprecated} annotation for the generated class or not
         */
        private Boolean docDeprecated;

        /**
         * Content that will be used with the {@code @deprecated} annotation in the javadoc, for the generated class
         */
        private String docDeprecatedContent;

        /**
         * Content that will be used with the {@code @version} annotation in the javadoc, for the generated class
         */
        private String docVersion;

        /**
         * Content that will be used with the {@code @since} annotation in the javadoc, for the generated class
         */
        private String docSince;

        /**
         * Prefix for the generated class name
         */
        private String typePrefix;

        /**
         * Suffix for the generated class name
         */
        private String typeSuffix = "Wraps";    // $NON-NLS-1$

        /**
         * Tab indents for multiply the space char
         */
        private int tabIndents = 4;

        /**
         * Indicate whether using {@code @Nullable} annotation on method parameters or not
         */
        private Boolean nullableAnnotation = Boolean.TRUE;

        /**
         * Specifies the implementation of {@code @Nullable} annotation
         */
        private String nullableAnnotationImpl = "jakarta.annotation.Nullable";    // $NON-NLS-1$

        /**
         * Whether only to generate the methods which marked as static
         */
        private Predicate<Method> methodFilter = MethodUtilsWraps::isPublic;

        /**
         * Whether to stops generation if the target class has none matching methods
         */
        private Boolean stopIfEmpty;

        /**
         * Prefix for the generated method names
         */
        private String methodPrefix;

        /**
         * Suffix for the generated method names
         */
        private String methodSuffix = "Quietly";    // $NON-NLS-1$

        public BuildParam addFileComment(@Nullable String comment) {
            fileComments.add(comment);
            return this;
        }

        public BuildParam clearFileComments() {
            fileComments.clear();
            return this;
        }

        public BuildParam addApiNote(@Nullable String apiNote) {
            apiNotes.add(apiNote);
            return this;
        }

        public BuildParam clearApiNotes() {
            apiNotes.clear();
            return this;
        }

        public BuildParam addImplNote(@Nullable String implNote) {
            implNotes.add(implNote);
            return this;
        }

        public BuildParam clearImplNotes() {
            implNotes.clear();
            return this;
        }

        public BuildParam addImplSpec(@Nullable String implSpec) {
            implSpecs.add(implSpec);
            return this;
        }

        public BuildParam clearImplSpecs() {
            implSpecs.clear();
            return this;
        }

        public BuildParam addSerials(@Nullable String serial) {
            serials.add(serial);
            return this;
        }

        public BuildParam clearSerials() {
            serials.clear();
            return this;
        }

        public BuildParam addSee(@Nullable String see) {
            sees.add(see);
            return this;
        }

        public BuildParam clearSees() {
            sees.clear();
            return this;
        }

        public BuildParam addAuthor(@Nullable String author) {
            authors.add(author);
            return this;
        }

        public BuildParam clearAuthors() {
            authors.clear();
            return this;
        }

        public BuildParam addSuppressWarning(@Nullable String warning) {
            suppressWarnings.add(warning);
            return this;
        }

        public BuildParam clearSuppressWarnings() {
            suppressWarnings.clear();
            return this;
        }
    }
}
